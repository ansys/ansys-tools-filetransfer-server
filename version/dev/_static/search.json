[{"objectID":"Home","href":"index.html#ansys-filetransfer-tool-server-documentation","title":"Ansys FileTransfer Tool Server documentation","text":"Ansys FileTransfer Tool Server documentation\n\nThe Ansys FileTransfer Tool is a simple gRPC API for moving files between a\nclient and a remote server. Its target use case are local Docker deployments or\nsimple remote deployments.\n\nThis documentation describes the server component of the FileTransfer Tool. For\ninformation on the tool itself, see the\nFileTransfer Tool documentation.\n\nThe FileTransfer Tool does not provide any security measures. Any file\non the server component can be accessed by any client. Without additional security\nmeasures, it is unsuited for use over an untrusted network.\n\nGetting started \n\nExplains how to build and run the FileTransfer Tool Server.\n\nintro\n\nContribute \n\nExplains how to set up a development environment and provides documentation for\nthe internal classes and functions of the FileTransfer Tool Server for developers\nwho want to understanding the inner workings of the server and possibly extend it.\n\ncontribute"},{"objectID":"Contribute","href":"contribute.html#contribute","title":"Contribute","text":"Contribute\n\nOverall guidance on contributing to a PyAnsys library appears in the\nContributing topic\nin the PyAnsys developer’s guide. Ensure that you are thoroughly familiar with\nthis guide before attempting to contribute to the FileTransfer Tool Server."},{"objectID":"Contribute","href":"contribute.html#setup","title":"Contribute > Setup","text":"Setup\n\nFor information on how to build the FileTransfer Tool Server from source, see\ngetting_started.\n\nTo build the documentation, use this command:\n\nTo run tests, use this command:\n\nTo run pre-commit style checks, run this command:"},{"objectID":"Contribute","href":"contribute.html#internal-api","title":"Contribute > Internal API","text":"Internal API\n\nDocumentation follows for the internal classes and functions of the FileTransfer Tool Server.\nThis documentation is intended for developers who want to understand the inner workings\nof the server and possibly extend it.\n\n\n\nnamespace file_transfer\n\nTypedefs\n\n\n\nusing pb_progress_t = decltype(::ansys::api::tools::filetransfer::v1::ProgressResponse().state())\n\n\n\n\n\nusing pb_filesize_t = decltype(::ansys::api::tools::filetransfer::v1::FileInfo().size())\n\n\n\nEnums\n\n\n\nenum Progress\n\nNamed constants for the progress of a file transfer operation. \n\nValues:\n\n\n\nenumerator INITIALIZED\n\n\n\n\n\nenumerator COMPLETED\n\n\n\n\n\nclass FileTransferServiceImpl : public ansys::api::tools::filetransfer::v1::FileTransferService::Service\n\nThis class implements the file transfer service. \n\nPublic Functions\n\n\n\nvirtual auto DownloadFile(::grpc::ServerContext *context, ::grpc::ServerReaderWriter<::ansys::api::tools::filetransfer::v1::DownloadFileResponse, ::ansys::api::tools::filetransfer::v1::DownloadFileRequest> *stream) -> ::grpc::Status override\n\nImplements the “DownloadFile” operation. \n\nParameters\n\ncontext – Server context to use. \n\nstream – Stream of requests and responses to process. \n\nReturns\n\nResult of the operation. \n\n\n\nvirtual auto UploadFile(::grpc::ServerContext *context, ::grpc::ServerReaderWriter<::ansys::api::tools::filetransfer::v1::UploadFileResponse, ::ansys::api::tools::filetransfer::v1::UploadFileRequest> *stream) -> ::grpc::Status override\n\nImplements the “UploadFile” operation. \n\nParameters\n\ncontext – Server context to use. \n\nstream – Stream of requests and responses to process. \n\nReturns\n\nResult of the operation. \n\n\n\nnamespace detail\n\nFunctions\n\n\n\nauto get_sha1_hex_digest(const boost::filesystem::path &path_, const std::streamsize chunk_size_ = 1024) -> std::string\n\nGet the SHA1 hex digest of a file. \n\nThis function is not thread-safe. \n\nParameters\n\npath_ – Path to the file. \n\nchunk_size_ – Size of the chunks to read from the file. \n\nReturns\n\nSHA1 hex digest of the file.\n\n\n\nnamespace download_impl\n\nTypedefs\n\n\n\nusing stream_t = ::grpc::ServerReaderWriter<api::DownloadFileResponse, api::DownloadFileRequest>\n\n\n\nFunctions\n\n\n\nauto get_request_checked(google::protobuf::Arena &arena_, stream_t *stream_, const api::DownloadFileRequest::SubStepCase &expected_step_) -> api::DownloadFileRequest*\n\n\n\n\n\nauto initialize(google::protobuf::Arena &arena_, stream_t *stream_) -> std::tuple<const boost::filesystem::path, const std::size_t, const std::streamsize>\n\n\n\n\n\nauto transfer(const boost::filesystem::path &file_path_, const std::size_t file_size_, const std::streamsize chunk_size_, google::protobuf::Arena &arena_, stream_t *stream_) -> void\n\n\n\n\n\nauto finalize(google::protobuf::Arena &arena_, stream_t *stream_) -> void\n\n\n\n\n\nnamespace exceptions\n\nFunctions\n\n\n\nauto convert_exceptions_to_status_codes(const std::function<void()>&) -> ::grpc::Status\n\nConvert exceptions to gRPC status codes. \n\nParameters\n\nfun – Function to execute. \n\nReturns\n\ngRPC status code. \n\n\n\nclass not_found : public std::runtime_error\n\nException type raised when an object is not found. \n\n\n\nclass invalid_argument : public std::runtime_error\n\nException type raised when invalid parameters are provided. \n\n\n\nclass failed_precondition : public std::runtime_error\n\nException type raised when some precondition is not met. For example, a file is expected to exist, but it does not. \n\n\n\nclass data_loss : public std::runtime_error\n\nException type raised when the transmitted data is lost or corrupted. \n\n\n\nclass internal : public std::runtime_error\n\nException type raised when an internal error occurs. \n\n\n\nnamespace detail\n\nFunctions\n\n\n\ntemplate<typename ExceptionT> auto get_exception_message(const ExceptionT &exc) -> std::string\n\n\n\n\n\nnamespace upload_impl\n\nTypedefs\n\n\n\nusing stream_t = ::grpc::ServerReaderWriter<api::UploadFileResponse, api::UploadFileRequest>\n\n\n\nFunctions\n\n\n\nauto get_request_checked(api::UploadFileRequest *request_, stream_t *stream_, const api::UploadFileRequest::SubStepCase &expected_step_) -> void\n\n\n\n\n\nauto get_request_checked(google::protobuf::Arena &arena_, stream_t *stream_, const api::UploadFileRequest::SubStepCase &expected_step_) -> api::UploadFileRequest*\n\n\n\n\n\nauto initialize(google::protobuf::Arena &arena_, stream_t *stream_) -> std::tuple<const boost::filesystem::path, const std::size_t, const std::string>\n\n\n\n\n\nauto transfer(const boost::filesystem::path &file_path_, const std::size_t file_size_, google::protobuf::Arena &arena_, stream_t *stream_) -> void\n\n\n\n\n\nauto finalize(const boost::filesystem::path &file_path_, const std::string &source_sha1_hex_, google::protobuf::Arena &arena_, stream_t *stream_) -> void\n\n"},{"objectID":"Getting started","href":"intro.html#getting-started","title":"Getting started","text":"Getting started"},{"objectID":"Getting started","href":"intro.html#clone-the-repository","title":"Getting started > Clone the repository","text":"Clone the repository\n\nYour first step is to clone the Filetransfer Tool Server repository and its submodules\nwith these commands:"},{"objectID":"Getting started","href":"intro.html#build-the-server","title":"Getting started > Build the server","text":"Build the server\n\nYou have two options for building the Filetransfer Tool Server:\n\nUse Docker: Build a Docker image that contains the server.\n\nUse a Manual build (Linux or Windows): Build the server directly on your machine.\n\nDocker\n\nTo build the Docker image, run the following command from the root of the repository:\n\nLinux\n\nTo build on Linux, you must have these tools installed:\n\npython3\n\ncmake\n\ng++ compiler\n\nFirst, you must install the development dependencies:\n\nThen, use Conan to fetch the C++ dependencies:\n\nFinally, use CMake to configure and build the project:\n\nWindows\n\nTo build on Windows, you must have these tools installed:\n\npython\n\ncmake\n\nMSVC compiler\n\nFirst, you must install the development dependencies:\n\nThen, use Conan to fetch the C++ dependencies:\n\nFinally, use CMake to configure and build the project:"},{"objectID":"Getting started","href":"intro.html#run-the-server","title":"Getting started > Run the server","text":"Run the server\n\nAfter the server is built, you can run it in the following ways:\n\nDocker\n\nThis starts the server and exposes it on port 50000.\n\nTo make the uploaded files available to another process, you can share a volume between two Docker containers. A Docker Compose file might look like this:\n\nLinux\n\n\n\nWindows\n\n"},{"objectID":"Getting started","href":"intro.html#command-line-options","title":"Getting started > Command-line options","text":"Command-line options\n\nThe Filetransfer Tool Server provides these command-line options:\n\n--help - Display a help message and exit.\n\n--server-address - Configure the address that the server is listening on."}]